Q1:why do we use super(props) inside constructor?
=> Super() function calls the constructor of the parent class. Using super constructor with props arguments basically allows accessing this.props in a Constructor function.

Q2:why cant we use async wwith useEffect?
=>Because Reactâ€™s useEffect hook expects a cleanup function returned from it which is called when the component unmounts. Using an async function here will cause a bug as the cleanup function will never get called.
NOTE: we cannot use async with function that hae a cleanup

Q3:What is the order of lifecycle methods?
=>
render phase:-
Constructor()
render()

commit phase:-
componentDidMount()
componentDidUpdate()
componentWillUnmount()


Q4:why do we use componentDidMount()
=>this is called whenever the render phase is finished.it is as same as useEffect in react which is executed after initial render
useEffect(()=>{},[])


Q5:why do we use componentWillUnmount
=>whenevere we leave the page this method is called
it is as similar as the return function is useEffect



useEffect(() => {
    const timer = setInterval(() => {
      console.log("timer");
    }, 1000);

    return () => {
      clearInterval(timer);
      console.log("componentWillUnmount");
    };
  }, []);






Q6:How do you create nested routes in react-router dom?
=>

const appRouter = createBrowserRouter([
  {
    path: "/",
    element: <App />,
    errorElement: <Error />,
    children: [
      {
        path: "about",
        element: <AboutUs />,
        children: [
          {
            path: "profile",
            element: <Profile />,
          },
        ],
      },
      {
        path: "/contact",
        element: <Contact />,
      },
      {
        path: "/",
        element: <Body />,
      },
      {
        path: "/restaurant/:id",
        element: <RestaurantDetail />,
      },
    ],
  },
  {
    path: "about",
    element: <AboutUs />,
  },
]);

